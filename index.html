<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crime Predictor Dashboard</title>

    <!-- 1. Leaflet (Map) CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- 2. Leaflet Geosearch (Search Bar) CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.11.0/dist/geosearch.css" />
    <script src="https://unpkg.com/leaflet-geosearch@3.11.0/dist/geosearch.umd.js"></script>

    <!-- 3. H3-js (for drawing grid cells) -->
    <script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>

    <!-- 4. Leaflet.heat (for the glowing bubble) -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <!-- 5. Tailwind CSS (for styling the UI) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        .leaflet-container {
            height: 100vh;
            width: 100%;
            z-index: 0;
        }
        #dashboard {
            z-index: 1000; /* Ensure dashboard is on top */
        }
        .leaflet-bar a, .leaflet-bar a:hover {
            line-height: 1.4 !important;
        }
        
        /* --- STYLES FOR LIGHT MODE (DEFAULT) --- */
        body { background-color: #f0f0f0; }
        .leaflet-geosearch-bar form {
            background-clip: padding-box;
            background-color: #ffffff;
            border-color: #ccc;
        }
        .leaflet-geosearch-bar form input {
            background-color: #ffffff;
            color: #333;
        }
        .leaflet-geosearch-bar .results {
            background-color: #ffffff;
        }
        .leaflet-geosearch-bar .results > li:hover, .leaflet-geosearch-bar .results > li.active {
            background-color: #f4f4f4;
        }

        /* --- STYLES FOR DARK MODE (WHEN .dark CLASS IS ADDED) --- */
        body.dark .leaflet-container {
            background-color: #222;
        }
        body.dark .leaflet-geosearch-bar form {
            background-color: #333;
            border-color: #555;
        }
        body.dark .leaflet-geosearch-bar form input {
            background-color: #333;
            color: #eee;
        }
        body.dark .leaflet-geosearch-bar .results {
            background-color: #333;
        }
        body.dark .leaflet-geosearch-bar .results > li:hover, body.dark .leaflet-geosearch-bar .results > li.active {
            background-color: #444;
        }
        body.dark #dashboard {
            background-color: rgba(31, 41, 55, 0.9); /* bg-gray-800 */
            color: white;
        }
        body.dark #search-container p {
            color: #9ca3af; /* text-gray-400 */
        }
        body.dark #risk-notification {
            color: white; /* Ensure text is white in dark mode */
        }
        /* Gauge Specific Styles */
#risk-gauge-container {
    position: relative;
    width: 250px;
    height: 125px;
    margin: 0 auto;
    overflow: hidden; /* Clips the circle to a semi-circle */
}
.gauge-arc {
    position: absolute;
    bottom: 0;
    width: 250px;
    height: 250px;
    border-radius: 50%;
    border-width: 50px; /* Thickness of the arc */
    border-style: solid;
    box-sizing: border-box;
}
/* Color definitions for the three arcs */
/* The clip styles define the arc segments (Red=Left, Yellow=Middle, Green=Right) */
#red-arc { 
    border-color: #dc2626 transparent transparent transparent; 
    clip: rect(auto, 125px, 125px, 0); /* Left Quarter (Red) */
}
#yellow-arc { 
    border-color: #eab308 transparent transparent transparent; 
    clip: rect(auto, 166.6px, 125px, 83.3px); /* Middle Quarter (Yellow) */
}
#green-arc { 
    border-color: #22c55e transparent transparent transparent; 
    clip: rect(auto, 250px, 125px, 125px); /* Right Quarter (Green) */
}

#gauge-needle {
    position: absolute;
    bottom: 0;
    left: 50%;
    /* Set pivot point to the bottom center of the gauge */
    transform-origin: 0 100%; 
    width: 2px;
    height: 125px;
    transition: transform 1s ease-in-out; /* Smooth movement */
    z-index: 10;
}
/* Initial needle color and center pin color */
#gauge-needle { background-color: #1f2937; } 
#gauge-center {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 15px;
    height: 15px;
    background-color: #1f2937; 
    border-radius: 50%;
    z-index: 20;
}
/* Dark mode adaptation for needle/center */
body.dark #gauge-needle, body.dark #gauge-center {
    background-color: #f3f4f6;
}

    </style>
</head>
<!-- Start in light mode by default -->
<body class="font-sans">

    <!-- The Map Container -->
    <div id="map" class="absolute top-0 left-0"></div>

    <!-- The Dashboard UI Container -->
    <div id="dashboard" class="absolute top-4 left-4 w-96 max-w-[90vw] p-4 bg-white bg-opacity-90 rounded-lg shadow-lg text-gray-900">
        <h1 class="text-2xl font-bold mb-3">Crime Predictor</h1>
        
        <!-- Search Bar will be added here by Leaflet Geosearch -->
        <div id="search-container" class="mb-3">
            <p class="text-sm text-gray-500">Search for a landmark or address:</p>
            <!-- Geosearch bar will attach itself here -->
        </div>

        <!-- "My Location" Button -->
        <button id="my-location-btn" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300">
            Use My Current Location
        </button>

        <!-- "Toggle Theme" Button -->
        <button id="toggle-theme-btn" class="w-full mt-2 bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-800 transition duration-300">
            Switch to Dark Mode
        </button>

        <!-- Risk Notification Area (GAUGE & CONTEXT) -->
<div id="risk-display-area" class="mt-4 p-4 rounded-lg bg-gray-50 dark:bg-gray-800 shadow-inner" style="display: none;">
    <!-- 1. The Risk Gauge -->
    <div id="risk-gauge-container">
        <!-- The three colored arcs (Red, Yellow, Green) -->
        <div id="red-arc" class="gauge-arc"></div>
        <div id="yellow-arc" class="gauge-arc"></div>
        <div id="green-arc" class="gauge-arc"></div>
        
        <!-- The Needle and Center Pin -->
        <div id="gauge-needle" style="transform: rotate(-90deg);"></div>
        <div id="gauge-center"></div>
    </div>

    <!-- 2. Risk Status Text -->
    <div id="risk-status-text" class="text-center mt-2 pb-2 border-b dark:border-gray-700">
        <!-- Risk level (Low/Medium/High) and Context status will be dynamically inserted here -->
    </div>

    <!-- 3. Contextual Grounding Data -->
    <h3 id="context-header" class="text-sm font-semibold mt-3 mb-1 text-gray-700 dark:text-gray-300" style="display: none;">
        <span class="inline-block w-2 h-2 bg-yellow-400 rounded-full mr-1"></span> Recent Confirmation (48hr):
    </h3>
    <ul id="context-list" class="space-y-1 text-sm text-gray-700 dark:text-gray-400 max-h-40 overflow-y-auto">
        <!-- Contextual articles populate here -->
    </ul>
</div>
    </div>

    <script>
        // --- 0. CONFIGURATION ---
        const API_BASE_URL = "https://find-crime-near-you.onrender.com";
        const H3_RESOLUTION = 9; 
        const ANALYSIS_RADIUS_KM = 2.0;
        
        // --- 1. INITIALIZE MAP & UI ---
        const map = L.map('map').setView([12.9716, 77.5946], 13); // Default to Bengaluru

        // --- DEFINE BOTH MAP SKINS ---
        const lightMap = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        });
        
        const darkMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 20
        });

        // --- DEFINE BOTH HEATMAP GRADIENTS ---
        const lightHeatGradient = { 0.4: 'yellow', 0.8: 'red', 1.0: '#b30000' };
        const darkHeatGradient = { 0.4: 'blue', 0.65: 'yellow', 1: 'red' };
        
        // --- ADD LIGHT MAP ON LOAD ---
        lightMap.addTo(map);
        let isDarkMode = false;
        
        // --- 1. INITIALIZE MAP & UI ---
// ... (lines 100-103)

const riskDisplayArea = document.getElementById('risk-display-area'); // <-- Use the new ID
const myLocationBtn = document.getElementById('my-location-btn');
const toggleBtn = document.getElementById('toggle-theme-btn');
        
        // --- 2. SETUP GEOSEARCH (Search Bar) ---
        const searchProvider = new GeoSearch.OpenStreetMapProvider();
        const searchControl = new GeoSearch.GeoSearchControl({
            provider: searchProvider,
            style: 'bar',
            showMarker: true,
            showPopup: false,
            autoClose: true,
            retainZoomLevel: false,
            animateZoom: true,
            keepResult: true,
            searchLabel: 'e.g., MG Road, Bengaluru',
        });
        map.addControl(searchControl);

        map.on('geosearch/showlocation', (result) => {
            const lat = result.location.y;
            const lon = result.location.x;
            analyzeLocation(lat, lon, `Risk at: ${result.location.label.substring(0, 30)}...`);
        });

        // --- 3. SETUP "MY LOCATION" BUTTON ---
        // *** THIS IS NOW FIXED: IT USES YOUR REAL LOCATION ***
        myLocationBtn.addEventListener('click', () => {
            riskDisplayArea.style.display = 'none';
            
            // --- THIS IS THE REAL GEOLOCATION CODE ---
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    map.setView([lat, lon], 15);
                    L.marker([lat, lon]).addTo(map).bindPopup("<b>You are here</b>").openPopup();
                    analyzeLocation(lat, lon, "Risk at your current location:");
                },
                (error) => {
                    alert(`Error getting location: ${error.message}`);
                }
            );

            // --- This is the hard-coded test (keep it for debugging) ---
            /*
            console.log("TEST: Forcing location to MG Road, Bengaluru to show hotspots.");
            const lat = 12.9716;
            const lon = 77.5946;
            map.setView([lat, lon], 15);
            L.marker([lat, lon]).addTo(map).bindPopup("<b>Test Location</b><br>MG Road").openPopup();
            analyzeLocation(lat, lon, "Risk at: MG Road, Bengaluru");
            */
        });

        // --- 4. NEW: SETUP THEME TOGGLE BUTTON ---
        toggleBtn.addEventListener('click', () => {
            isDarkMode = !isDarkMode; // Flip the state
            if (isDarkMode) {
                // Switch to Dark Mode
                document.body.classList.add('dark');
                map.removeLayer(lightMap);
                darkMap.addTo(map);
                toggleBtn.innerText = 'Switch to Light Mode';
                // Update heatmap colors if it exists
                if (heatmapLayer) {
                    heatmapLayer.setOptions({ gradient: darkHeatGradient });
                }
            } else {
                // Switch to Light Mode
                document.body.classList.remove('dark');
                map.removeLayer(darkMap);
                lightMap.addTo(map);
                toggleBtn.innerText = 'Switch to Dark Mode';
                // Update heatmap colors if it exists
                if (heatmapLayer) {
                    heatmapLayer.setOptions({ gradient: lightHeatGradient });
                }
            }
        });

        // --- 5. MASTER ANALYSIS FUNCTION ---
        async function analyzeLocation(lat, lon, title) {
            clearMapLayers(); 
            
            const radiusInMeters = ANALYSIS_RADIUS_KM * 1000;
            analysisCircleLayer = L.circle([lat, lon], {
                radius: radiusInMeters,
                color: "#ef4444",       // Red outline
                weight: 2,
                fillColor: "#ef4444",   // Red fill
                fillOpacity: 0.1
            }).addTo(map);

            const [riskData, hotspotData] = await Promise.all([
                getLiveRisk(lat, lon),
                getHistoricalHotspots(lat, lon, ANALYSIS_RADIUS_KM)
            ]);

            visualizeRisk(riskData, title);
            visualizeHotspots(hotspotData); 
        }

        // --- 6. API CALL: /predict_risk ---
        async function getLiveRisk(lat, lon) {
            try {
                const response = await fetch(`${API_BASE_URL}/predict_risk`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ latitude: lat, longitude: lon })
                });
                return await response.json();
            } catch (error) {
                console.error("Error fetching risk prediction:", error);
                return null;
            }
        }

        // --- 7. API CALL: /get_hotspots ---
        async function getHistoricalHotspots(lat, lon, radius_km) {
            try {
                const response = await fetch(`${API_BASE_URL}/get_hotspots?lat=${lat}&lon=${lon}&radius_km=${radius_km}`);
                return await response.json();
            } catch (error) {
                console.error("Error fetching hotspots:", error);
                return null;
            }
        }

        // --- 8. VISUALIZATION ---
        
        let riskPolygonLayer;
        let heatmapLayer; 
        let analysisCircleLayer; 

        function visualizeRisk(data, title) {
            if (!data) return;

            document.getElementById('risk-display-area').style.display = 'block';
            
            const needle = document.getElementById('gauge-needle');
            const riskStatusText = document.getElementById('risk-status-text');
            const contextList = document.getElementById('context-list');
            const contextHeader = document.getElementById('context-header');

            // 1. Determine Needle Rotation and Text based on final risk code (0, 1, or 2)
            let rotationDeg; // -90 (Green), 0 (Yellow), 90 (Red)
            let riskText;
            let textColorClass;
            let riskColor;

            switch (data.risk_code) {
                case 0: 
                    rotationDeg = -90;
                    riskText = "LOW RISK";
                    textColorClass = "text-green-600 dark:text-green-400";
                    riskColor = '#22c55e';
                    break;
                case 1:
                    rotationDeg = 0;
                    riskText = "MEDIUM RISK";
                    textColorClass = "text-yellow-600 dark:text-yellow-400";
                    riskColor = '#f59e0b';
                    break;
                case 2:
                    rotationDeg = 90;
                    riskText = "HIGH RISK";
                    textColorClass = "text-red-600 dark:text-red-400";
                    riskColor = '#ef4444';
                    break;
                default:
                    rotationDeg = 0;
                    riskText = "UNKNOWN";
                    textColorClass = "text-gray-500";
                    riskColor = '#6b7280';
            }

            // Apply Rotation to Needle
            needle.style.transform = `rotate(${rotationDeg}deg) translateX(-50%)`;
            
            // Update Text Display
            riskStatusText.innerHTML = 
                `<p class="text-xs text-gray-500 dark:text-gray-400">${title}</p>
                <span class="${textColorClass} font-bold text-3xl block">${riskText}</span>
                <p class="text-sm text-gray-500 dark:text-gray-400 mt-1">Prediction Status: ${data.context_status}</p>`;

            // 2. Draw H3 Prediction Hexagon
            if (data.h3_index) {
                const boundary = h3.cellToBoundary(data.h3_index, true);
                
                riskPolygonLayer = L.polygon(boundary, {
                    color: riskColor,
                    weight: 3,
                    fillColor: riskColor,
                    fillOpacity: 0.3
                }).addTo(map);
            }
            
            // 3. Update Contextual Data List
            contextList.innerHTML = ''; // Clear previous list
            if (data.context_data && data.context_data.length > 0) {
                contextHeader.style.display = 'block';
                contextHeader.innerHTML = `<span class="inline-block w-2 h-2 bg-yellow-400 rounded-full mr-1"></span> Recent Confirmation (${data.context_data.length} Reports):`;
                
                data.context_data.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'text-xs border-b border-gray-200 dark:border-gray-700 py-1 last:border-b-0';
                    li.innerHTML = `
                        <a href="${item.link}" target="_blank" class="hover:text-blue-500 transition duration-150 block truncate">
                            <span class="font-semibold">${item.title}</span> 
                            <span class="text-gray-400">(${item.location})</span>
                        </a>`;
                    contextList.appendChild(li);
                });
            } else {
                contextHeader.style.display = 'none';
                contextList.innerHTML = `<li class="text-xs text-gray-500 dark:text-gray-400 py-1">No recent contextual news found (48 hr window).</li>`;
            }
        }

        // --- THIS FUNCTION IS NOW FIXED FOR LIGHT/DARK MODE ---
        function visualizeHotspots(data) {
            if (!data || !data.hotspots || data.hotspots.length === 0) {
                console.log("No historical hotspots to display.");
                return;
            }

            console.log(`Received ${data.hotspots.length} hotspots, drawing heatmap...`);

            const heatPoints = data.hotspots.map(crime => {
                return [crime.latitude, crime.longitude, 0.2]; // [lat, lon, intensity]
            });

            // Check current theme to apply the correct gradient
            const currentGradient = isDarkMode ? darkHeatGradient : lightHeatGradient;

            heatmapLayer = L.heatLayer(heatPoints, {
                radius: 25,
                blur: 20,
                maxZoom: 18,
                gradient: currentGradient // Use the dynamic gradient
            }).addTo(map);
        }

        function clearMapLayers() {
            if (riskPolygonLayer) {
                map.removeLayer(riskPolygonLayer);
            }
            if (heatmapLayer) {
                map.removeLayer(heatmapLayer);
            }
            if (analysisCircleLayer) { 
                map.removeLayer(analysisCircleLayer);
            }
        }
    </script>
</body>
</html>